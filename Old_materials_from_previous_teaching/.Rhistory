library(auriel)
data<-matrix(1:20000000,nrow=10000000,ncol=2) #(10 million entries and 20 million rows!!!)
ptm <- proc.time()
for(i in 1:10000000){data2<-data[i,1]+data[i,2]}
proc.time() - ptm
ptm<-proc.time()
data2<-data[i,1] + data[i,2]
proc.time() - ptm
values<-c(30,25,6)
for(i in values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold')),print(d))
}
temp_fun<-function(temp_values){
for(i in temp_values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold')), print(d))
rm(temp_values)
}}
temp_fun(1)
temp_fun(c(1:100))
mtcars %>% head
row.names(mtcars)=='Pontiac Firebird'
colnames(mtcars)=='mpg'
mtcars %>%
add_rownames(var="model") %>%
filter(model=='Pontiac Firebird') %>%
select(mpg)
library(dplyr)
mtcars %>% head
row.names(mtcars)=='Pontiac Firebird'
colnames(mtcars)=='mpg'
mtcars %>%
add_rownames(var="model") %>%
filter(model=='Pontiac Firebird') %>%
select(mpg)
mtcars[25,1]
which(row.names(mtcars)=='Pontiac Firebird') - 1   ##gives us the row just before Pontiac Firebird
folder<-'Monstersinc'
file<-'scaretotal_MikeW_March.csv'
paste0(folder,'/',file)   # so its going to look in what ever folder we told it (Monstersinc in this case)
read.csv(paste0(folder,'/',file))
setwd('Monstersinc')
name<-'MikeW'
month<-'March'
data<-read.csv(paste0('scaretotal_',name,'_',month,'.csv'))
our.list<-list()
name<-c('MikeW','JamesS')
month<-c('March','April')
for(i in name){
for(p in month){
our.list[[paste0(i,'_',p)]]<-read.csv(paste0('scaretotal_',i,'_',p,'.csv'))
}  ##end p loop
}   ###end i loop
summary(our.list)
data<-c(1:10)   ###data as a vector
ci<-.01         ###confidence
sd.data<-sd(data)   #this function calculates the standard deviation, whew that was easy
n<-length(data)    #length takes the length of a vector, well thats the same as N, right?
sem<-sd.data/n    # put them together. And there we go, we have sd/sqrt(n) also known as the standard error of the mean (sem)
tvalue<-qt(ci,(length(data)-1))   ###with that we can write this
mean.data<-mean(data)   ##the mean can be calculated with the mean function
sem*tvalue   ##gives us our interval
upper<-mean.data + sem*tvalue   ##putting it all together, this gives us our upper range
lower<-mean.data - sem*tvalue   ## our lower
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
data<-c(1:10)   ###data as a vector
ci<-.01         ###confidence
########################################
##start of code
if(ci>abs(1)){print("You can't have a probability greater than 1 stupid!")}else{
sd.data<-sd(data)
n<-length(data)
tvalue<-qt(ci,(length(data)-1))
sem<-sd.data/n
mean.data<-mean(data)
upper<-mean.data + sem*tvalue
lower<-mean.data - sem*tvalue
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
list1<-list(upperbound=upper,lowerbound=lower,mean=mean.data)
}
CI.fun<-function(data,ci){
if(ci>abs(1)){print("You can't have a probability greater than 1 stupid!")}else{
sd.data<-sd(data)
n<-length(data)
sem<-sd.data/n
tvalue<-qt(ci,(length(data)-1))
mean.data<-mean(data)
upper<-mean.data + sem*tvalue
lower<-mean.data - sem*tvalue
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
list1<-list(upperbound=upper,lowerbound=lower,mean=mean.data)
}}
result<-CI.fun(1:100,.95)    ##try it with a data vector of all integers between 1 and 100
result<-CI.fun(sample.int(100,20),.95)   ###try it with a data vector of 20 random numbers
CI.fun(1:10,2)
CI.fun<-function(data,ci){
range<-sd(data)/length(data) * qt(ci,(length(data)-1))
mean.data<-mean(data)
list1<-list(upper=mean.data+range,lower=mean.data-range,mean=mean.data)
print(list1)
}
result<-CI.fun(1:10,.95)
states<-'OK'
years<-2008
url1<-paste0('http://ebird.org/ebird/BarChart?cmd=getChart&displayType=download&getLocations=states&states=US-',
states,
'&bYear=',
years,
'&eYear=',
years,
'&bMonth=1&eMonth=12&reportType=location&parentState=US-',
states
)
download.file(url1,paste0('eBird_',states,'_',years))
data<-read.delim(paste0('eBird_',states,'_',years),skip=14,header=F,row.names=1)[,1:48]
head(data)
colnames(data)<-paste0(rep(1:12,each=4),'.',1:4)   ###renames the columns in a manner we want
write.csv(data,paste0('eBird_',states,'_',years,'.csv'))   ###writes the file as a csv, and names it how we want
file.remove(paste0('eBird_',states,'_',years))  ### a very dangerous function, you need to know exactly what youre refering too, but this removes the .txt file originally downloaded
states<-c('OK','TX')
years<-c(2008:2014)
url1<-paste0('http://ebird.org/ebird/BarChart?cmd=getChart&displayType=download&getLocations=states&states=US-',
i,
'&bYear=',
p,
'&eYear=',
i,
'&bMonth=1&eMonth=12&reportType=location&parentState=US-',
p
)  ###end of paste
download.file(url1,paste0('eBird_',i,'_',p))
data<-read.delim(paste0('eBird_',i,'_',p),skip=14,header=F,row.names=1)[,1:48]
colnames(data)<-paste0(rep(1:12,each=4),'.',1:4)
write.csv(data,paste0('eBird_',i,'_',p,'.csv'))
file.remove(paste0('eBird_',i,'_',p))  ### a very dangerous function, you need
list1<-list(id=1:10,matr=matrix(1:100,nrow=10,ncol=10),df=data.frame(id=1:10,name=rep(c('a','b'),10)))
str(list1[[2]])  ##when you refer to it like this its output is a dataframe
str(list1[2])  ## when you call it with this it returns a list
list1$id   ##but you can still call them with the $
list1[[3]][1,1]  #refers to the 1st row, 1st column, of the 3rd object in list1.
datag<-gapminder
head(datag)
# say we want to look at the life expectancy of just European countries in 1987, and we only
# want to look at life Exp and gdpPercap
test<- datag %>%
filter(continent=='Europe',
year==1987) %>%
select(country,lifeExp,gdpPercap)
data(gapminder)
library(dplyr)
library(gapminder)
data("gapminder")
datag<-gapminder
library(gapminder)
data(gapminder)
head(gapminder)
test<- gapminder %>%
filter(continent=='Europe',
year==1987) %>%
select(country,lifeExp,gdpPercap)
head(test)
test<- gapminder %>%
filter(continent=='Europe',
year==1987) %>%
select(-continent, -pop))
test<- gapminder %>%
filter(continent=='Europe',
year==1987) %>%
select(-continent, -pop)
test
gapminder %>%
filter(continent=="Europe"|continent=="Asia")
gapminder %>%
filter(continent=="Europe"|continent=="Asia",
year==1987)
test <- gapminder %>%
filter(continent=="Europe"|continent=="Asia",
year==1987) %>%
select(country, lifeExp, gdpPercap)
test
#find all the variables in 'this' that are also in 'that'
this<-c("a","b","c","d")
that<-c("d","e")
this %in% that  ### should be read as, find all the moments where THIS is equal to THAT. It returns T/F of where this 1:10 equals 1 or 2. If we feed this back into our vector THIS it shows us the numbers themselves
this[this %in% that]
that %in% this
that[that %in% this]  ###we can do it the other way around, and it shows us the same two numbers ofcourse. It is where the two vectors have in common
(this== that[1] | this == that[2])  ##look for all moments in THIS that equal 1 or 2. This gets inefficent quickly
intersect(this,that)
which(this %in% that)
data<-read.csv('rail_data.csv')
data
data<-read.csv('rail_data.csv', stringsAsFactors = FALSE)
setwd("~/naoc_2016_r_workshop")
data<-read.csv('rail_data.csv', stringsAsFactors = FALSE)
head(data)
#lets subset our data into two dataframes for ease in this example.
data1<-data %>% select(wingchord, culmen, tarsus)    #a data frame called data1
grouping<- data %>% select(genera, migratory)
tapply(data1$wingchord, grouping$genera, mean)
data %>%
group_by(genera) %>%
summarize(mean(wingcord))
data %>%
group_by(genera) %>%
summarize(mean(wingchord))
by(data1, grouping$genera, data.frame)
by(data1, grouping$genera, mean)
aggregate(data1, by = list(grouping$genera, grouping$migratory), mean)    # so the by= has to be a list, so just get used to typing by = list( all my groups)
data %>%
group_by(genera, migratory) %>%
summarize(mean(winchord))
data %>%
group_by(genera, migratory) %>%
summarize(mean(wingchord))
data %>%
group_by(genera, migratory) %>%
summarize_each(funs(mean))
data<-data.frame(matrix(1:100, nrow=10,ncol=10))
data
#apply does some function across the rows or columns of a data set
apply(data,1,mean)  #1 tells it to run a function across the rows
apply(data,2,mean)  #2 tells it to run a function down the columns
data
apply(data/apply(data,1,sum),1,sum)  ##proof that it calculated the proportion (these values would not equal 1 otherwise)
apply(data,1,mean)  #1 tells it to run a function across the rows
data %>%
rowwise() %>%
summarize_each(funs(sum))
data %>%
rowwise() %>%
summarize(funs(sum))
data %>%
lapply(table) %>%
lapply(as.dtaa.frame)
data %>%
lapply(table) %>%
lapply(as.data.frame)
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
rbind_all()
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
rbind_all() %>%
group_by(var) %>%
summarize(mean(Var1))
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
Map(cbind, var=names(data),.)
rbind_all() %>%
group_by(var) %>%
summarize(mean(Var1))
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
Map(cbind, var=names(data),.) %>%
rbind_all() %>%
group_by(var) %>%
summarize(mean(Var1))
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
Map(cbind, var=names(data),.) %>%
rbind_all() %>%
group_by(var) %>%
summarize(mean(Var1, na.rm=TRUE))
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
Map(cbind, var=names(data),.) %>%
rbind_all() %>%
group_by(var)
data %>%
lapply(table) %>%
lapply(as.data.frame) %>%
Map(cbind, var=names(data),.) %>%
rbind_all() %>%
group_by(var) %>% unique()
t(data)
grep('United',gapminder$country)   #this searches for the term 'United' in each word in our country vector
gapminder[grep('United',gapminder$country),]    # we can feed this back to our data frame to see all countries that contain the word United (case sensitive)
grep('^Af',gapminder$country)   #searches for countries that START with Af
gapminder[grepl('^Af',gapminder$country),]
gapminder[grepl('Af',gapminder$country),]
