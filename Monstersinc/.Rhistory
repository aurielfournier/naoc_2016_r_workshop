# which can be really useful when you have time stamps in your file name and you need to choose the right time
# We want to make a data set that creates a life list and tells me when, where, and what bird each life bird was lets start by creating a true date time column. That way we basically know to the hour when we first saw a bird
# first we have to fudge a bit and say if there isn't an hour we'll assume it was noon
myebird <- myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
mutate(lifebird = 1:n())
################################################
myebird<-read.csv('my_ebird_data.csv', stringsAsFactors = FALSE)
# now this data set has a lot going on, it has a lot of superfulous data, mix of data (x and numbers)
str(myebird)
####a For our purposes today we are going to consider "Xs" 1s, which may or may not be appropriate depending on what you are doing. But for today, we'll do it.
myebird <- myebird %>%
mutate(count = replace(count, count=='X',1), # changes X's to 1s
count = as.numeric(count)) # makes the column numeric now that the X's are gone
str(myebird)
##lets do some quick cleaning, I do not want all these columns
colnames(myebird)
myebird<- myebird %>%
select(-scientificname,-taxonomicorder,-allobsreported,-numberofobservers,-breedingcode,-speciescomments,-checklistcomments)
#### now lets further fix some of this, for some future analysis
# For example I am interested in my life list, this data set doesn't explicitly state anything about my life birds. So let's make a life list.
#########dates and times#############################
# We're first going to need to tackle dates. R can handle dates, and it can be quite powerful, but a bit annoying.
# The base functions for this are as.Date, as.POSIXct, as.POSIXlt
# The syntax for these is essentially the same, feed it a date, and tell it the format
Sys.time()
## Good Resource on what letters = what in format
# https://stat.ethz.ch/R-manual/R-devel/library/base/html/strptime.html
dt<-as.Date(Sys.time(),format='%Y-%m-%d')
ct<-as.POSIXct(Sys.time(),format='%Y-%m-%d %H%M%D')
lt<-as.POSIXlt(Sys.time(),format='%Y-%m-%d %H%M%D')
# whats great is we can now do math on time
dt-10   ##since day is the lowest measurement it counts in days
ct-10   ##however counts in seconds
lt-10   ##does the same thing
# as.POSIXlt is really useful because it allows you to call particular pieces of the time out
lt$yday   ##julian date
lt$hour   ##hour
lt$year   ##what.....time since 1900???
lt$year+1900  ##converts you to standard time
##these are particularly useful because you can do math on time
earlytime<-as.POSIXct('2015-03-23',format='%Y-%m-%d')
ct - earlytime
##as well as logical statements
ct > earlytime
ct == earlytime
# which can be really useful when you have time stamps in your file name and you need to choose the right time
# We want to make a data set that creates a life list and tells me when, where, and what bird each life bird was lets start by creating a true date time column. That way we basically know to the hour when we first saw a bird
# first we have to fudge a bit and say if there isn't an hour we'll assume it was noon
myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
mutate(lifebird = 1:nrow())
myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1)
myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
mutate(lifebird = 1:n())
myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
ungroup() %>%
mutate(lifebird = 1:n())
# first we have to fudge a bit and say if there isn't an hour we'll assume it was noon
myebird <- myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
ungroup() %>%
mutate(lifebird = 1:n())
summary(myebird$lifebird)
ggplot(myebird,aes(timez,lifebird)) + geom_line()
myebird <- myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
ungroup() %>%
arrange(timez) %>%
mutate(lifebird = 1:n())
ggplot(myebird,aes(timez,lifebird)) + geom_line()
################################################
myebird<-read.csv('my_ebird_data.csv', stringsAsFactors = FALSE)
# now this data set has a lot going on, it has a lot of superfulous data, mix of data (x and numbers)
str(myebird)
####a For our purposes today we are going to consider "Xs" 1s, which may or may not be appropriate depending on what you are doing. But for today, we'll do it.
myebird <- myebird %>%
mutate(count = replace(count, count=='X',1), # changes X's to 1s
count = as.numeric(count)) # makes the column numeric now that the X's are gone
str(myebird)
##lets do some quick cleaning, I do not want all these columns
colnames(myebird)
myebird<- myebird %>%
select(-scientificname,-taxonomicorder,-allobsreported,-numberofobservers,-breedingcode,-speciescomments,-checklistcomments)
#### now lets further fix some of this, for some future analysis
# For example I am interested in my life list, this data set doesn't explicitly state anything about my life birds. So let's make a life list.
#########dates and times#############################
# We're first going to need to tackle dates. R can handle dates, and it can be quite powerful, but a bit annoying.
# The base functions for this are as.Date, as.POSIXct, as.POSIXlt
# The syntax for these is essentially the same, feed it a date, and tell it the format
Sys.time()
## Good Resource on what letters = what in format
# https://stat.ethz.ch/R-manual/R-devel/library/base/html/strptime.html
dt<-as.Date(Sys.time(),format='%Y-%m-%d')
ct<-as.POSIXct(Sys.time(),format='%Y-%m-%d %H%M%D')
lt<-as.POSIXlt(Sys.time(),format='%Y-%m-%d %H%M%D')
# whats great is we can now do math on time
dt-10   ##since day is the lowest measurement it counts in days
ct-10   ##however counts in seconds
lt-10   ##does the same thing
# as.POSIXlt is really useful because it allows you to call particular pieces of the time out
lt$yday   ##julian date
lt$hour   ##hour
lt$year   ##what.....time since 1900???
lt$year+1900  ##converts you to standard time
##these are particularly useful because you can do math on time
earlytime<-as.POSIXct('2015-03-23',format='%Y-%m-%d')
ct - earlytime
##as well as logical statements
ct > earlytime
ct == earlytime
# which can be really useful when you have time stamps in your file name and you need to choose the right time
# We want to make a data set that creates a life list and tells me when, where, and what bird each life bird was lets start by creating a true date time column. That way we basically know to the hour when we first saw a bird
# first we have to fudge a bit and say if there isn't an hour we'll assume it was noon
new <- myebird %>%
mutate(time = replace(time, nchar(time)==0, '12:00 PM'),
timez = as.POSIXct(paste(date, time),format="%m/%d/%Y %I:%M %p")) %>%
group_by(commonname) %>%
arrange(timez) %>%
slice(1) %>%
ungroup() %>%
arrange(timez) %>%
mutate(lifebird = 1:n())
ggplot(new,aes(timez,lifebird)) + geom_line()
myebird <- myebird %>%
mutate(effortcount = count + distancetraveledkm)
summary(myebird$effortcount)
myebird <- myebird %>%
filter(!is.na(effortcount))
summary(myebird$effortcount)
gg<- gdat %>% select(-pop,-gdppercap) %>% spread(year, lifeexp) %>% head()
gg<- gapminder %>% select(-pop,-gdppercap) %>% spread(year, lifeexp) %>% head()
data(gapminder)
colnames(gapminder) <- tolower(colnames(gapminder)
colnames(gapminder) <- tolower(colnames(gapminder))
colnames(gapminder) <- tolower(colnames(gapminder))
gg<- gapminder %>% select(-pop,-gdppercap) %>% spread(year, lifeexp) %>% head()
gg
gapminder %>% select(-pop,-gdppercap) %>% spread(year, lifeexp) %>% head()
gapminder %>% select(-lifeexp, -gdppercap) %>% spread(year, pop) %>% head()
gapminder %>% select(-pop, -lifeexp) %>% spread(year, gdppercap) %>% head()
gapminder %>% gather(variable, value, c(1,3:14)) %>% head
gapminder %>% gather("variable","value") %>% head
head(gapminder)
gapminder %>% gather("variable","value", -country) %>% head
gdat <- gapminder %>% mutate(id=paste("A", 1:nrow(gdat),sep="_"))
gdat <- gapminder %>% mutate(id=paste("A", 1:n(),sep="_"))
head(gdat)
gathered <- gdat %>%  gather(id) %>% separate(id, into=c("letter","number"),sep="_")
head(gathered)
gathered <- gdat %>%  gather(id)
gathered <- gdat %>%  gather(id) %>% head
gdat %>%  gather(id) %>% head
gdat %>% gather(id) %>% separate(id, into=c("letter","number"),sep="_") %>% head
gdat %>% gather(id) %>% separate(id, into=c("letter","line","num"), sep=c(1,2))  %>% head
newdat <- data.frame(country = unique(gdat$country)[1:135], number=seq(1,135), by=1 , other="thinghere", new="otherthinghere")
newda5t %>% head
newdat %>% head
gdat %>% full_join(newdat, by="country") %>% head
left_join(newdat, by="country") %>% head
gdat %>% left_join(newdat, by="country") %>% head
gdat %>% left_join(newdat, by="country") %>% head
gdat %>% left_join(newdat, by="country") %>% nrow
gdat %>% full_join(newdat, by="country") %>% head
gdat %>% full_join(newdat, by="country") %>% nrow
newdat %>% nrow
gdat %>% full_join(newdat, by="country") %>% head
gdat %>% full_join(newdat, by="country") %>% nrow
gdat %>% left_join(newdat, by="country") %>% head
gdat %>% left_join(newdat, by="country") %>% nrow
gdat %>% right_join(gdat, newdat, by="country") %>% head
gdat %>% right_join(gdat, newdat, by="country") %>% nrow
gdat %>% right_join(newdat, by="country") %>% head
gdat %>% right_join(newdat, by="country") %>% nrow
gdat <- gapminder %>% mutate(id=paste("A", 1:n(),sep="_"))
gdat %>%  gather(id) %>% head
### seperate
# I realize this is an arbitary id value that we are trying to seperate
# but this is super useful for lots of things
# how to split based on some kind of seperation character
gdat %>% gather(id) %>% separate(id, into=c("letter","number"),sep="_") %>% head
# how to split based on the number of digits, can be one number or multiple
gdat %>% gather(id) %>% separate(id, into=c("letter","line","num"), sep=c(1,2))  %>% head
# if you have a seperation character that you are willing to loose then using sep = "character" is the way to go, but that is not always the case
#########################
### merging/joining data frames
#########################
# THIS IS SUPER POWERFUL (dplyr)
## merging with different columns
# ok lets create some silly data that we want to merge with our gdat dataset
newdat <- data.frame(country = unique(gdat$country)[1:135], number=seq(1,135), by=1 , other="thinghere", new="otherthinghere")
newdat %>% head
newdat %>% nrow
## keeps everything from both gdat and newdat
gdat %>% full_join(newdat, by="country") %>% head
gdat %>% full_join(newdat, by="country") %>% nrow
## keeps the rows of the left dataframe and adds those that match from the right
gdat %>% left_join(newdat, by="country") %>% head
gdat %>% left_join(newdat, by="country") %>% nrow
# keeps the rows of the right data frame and adds those that match from the left
gdat %>% right_join(newdat, by="country") %>% head
gdat %>% right_join(newdat, by="country") %>% nrow
newdat %>% right_join(gdat, by="country") %>% head
newdat %>% right_join(gdat, by="country") %>% nrow
gdat %>% right_join(newdat, by="country") %>% head
gdat %>% right_join(newdat, by="country") %>% nrow
nrow(newdat)
gdat1 <- gdat[1:1000,]
gdat2 <- gdat[999:1704,]
gdat1 %>% intersect(gdat2) %>% nrow()
gdat1 %>% union(gdat2) %>% nrow()
gdat1 %>% setdiff(gdat2) %>% nrow()
gdat %>%
group_by(country)
mean <- gdat %>%
group_by(country) %>%
select(lifeexp, pop, gdppercap) %>%
summarise_each(funs(mean))
mean
median <- gdat %>%
group_by(country) %>%
select(lifeexp, pop, gdppercap) %>%
summarise_each(funs(median))
median
sd <- gdat %>%
group_by(country) %>%
select(lifeexp,pop, gdppercap) %>%
summarise_each(funs(sd))
sd
n <- gdat %>%
group_by(country) %>%
select(4:6) %>% # you can also call columns by number
summarise_each(funs(length))
n
se <- sd[,2:4] / sqrt(n[,2:4])
se <- cbind("country"=sd[,1], se)
head(se)
se %>% head
##                            by - Matt Boone (2015)                           ##
library (dplyr)
library (ggplot2)
if(2>1){print("You can do math")}    ## 2 is greater than 1, so it did what was between the brackets
if(1>2){print("You can't do math")}   ##1 is not greater than 2 so it did nothing
tt<-sample.int(10,1)
tt   #is our random number
if(tt>5){
print('number is greater than 5') } else {
print('number is less than 5')}
if(tt>5){print('number is greater than 5')}else{if(tt<5){print('number is less than 5')}else{if(tt==5){print('number is 5')}}}   # this now adds the next possibility, if the number is not greater than 5,
if(tt>5){print('number is greater than 5')}
else{if(tt<5){print('number is less than 5')}
else{if(tt==5){print('number is 5')}}}
ifelse(tt>5,print('number is greater than 5'),
ifelse(tt<5,print('number is less than 5'),
ifelse(tt==5,print('number is 5'))))
ifelse(tt>5,print('number is greater than 5'),
ifelse(tt<5,print('number is less than 5'),
ifelse(tt==5,print('number is 5'))))
ifelse(data[,1]>5,
paste('number is larger than 5'),
ifelse(data[,1]<5,
paste('number is not larger than 5'),
paste('number is 5')))
ifelse(tt>5,
paste('number is larger than 5'),
ifelse(data[,1]<5,
paste('number is not larger than 5'),
paste('number is 5')))   #runs the same set of instrictions but automatically
data <- data.frame(a=runif(10,5,2))
data
a bit hard to get your head around
data <- data.frame(a=runif(10,5))
data
?runif
data <- data.frame(a=runif(10,10,0))
data
runif(10,10,0)
data <- data.frame(a=1:10)
data
data[,1]
ifelse(data[,1]>5,
paste('number is larger than 5'),
ifelse(data[,1]<5,
paste('number is not larger than 5'),
paste('number is 5')))   #runs the same set of instrictions but automatically
for(i in 1:10){ print(i) }   ###what did this do?
for(i in 1:10){
#stores the value as the variable i (or any variable name we told it to)
i<-1
#and then runs EVERYTYHING between the brackets with the variable as that value
print(i)
}
for(i in 1:10){print(i+1)}  ## in this case we want to add 1 to that value. So it took 1 and added 1
data<-matrix(1:100,nrow=10,ncol=10)
data
for(i in 1:10){print(data[i,1])}    ### is going to loop through all the rows in column 1 (and print
for(i in 1:10){print(data[i,2])}    ###loops through all the rows in column 2 (and prints that value)
for(i in 1:10){print(data[i,1]+5)}   ###loops through all the rows in column 1 and adds 5 to that
for(i in 1:10){data[i,2]<-data[i,1]+5}   ###does the same thing but stores the value in the correct
data
data[i,2]<- data[i,1]+5  ###is the best way to do this particular task
paste0('hd',1:10)   ### automatically adds the numbers 1 through 10 onto the word 'hd'
data[,1]
for(i in 1:10){
if(data[i,1]>5){print(paste0(i,' is larger than 5'))}else{print(paste0(i,' is not larger than 5'))}
}
data<-matrix(1:20000000,nrow=10000000,ncol=2) #(10 million entries and 20 million rows!!!)
ptm <- proc.time()
for(i in 1:10000000){data2<-data[i,1]+data[i,2]}
proc.time() - ptm
ptm<-proc.time()
data2<-data[i,1] + data[i,2]
proc.time() - ptm
values<-c(30,25,6)
values
for(i in values){
d<-i*9/5 +32
print(d)
if(d<50){print(paste0(d,' degrees is cold'))}
}
for(i in values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold'),
print(d)))
}
for(i in values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold'),
print(d)))
}
for(i in values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold')),print(d))
}
temp_fun<-function(temp_values){
for(i in temp_values){
d<-i*9/5 +32
print(d)
if(d<50){print(paste0(d,' degrees is cold'))}
rm(temp_values)
}}
temp_fun(1)
temp_fun(c(1:100))
temp_fun<-function(temp_values){
for(i in temp_values){
d<-i*9/5 +32
ifelse(d<50,print(paste0(d,' degrees is cold')), print(d))
rm(temp_values)
}}
temp_fun(1)
temp_fun(c(1:100))
mtcars %>% head
row.names(mtcars)=='Pontiac Firebird'
colnames(mtcars)=='mpg'
mtcars[row.names(mtcars)=='Pontiac Firebird','mpg'] # as opposed to
mtcars %>%
filter(row.names=='Pontiac Firebird')
mtcars %>%
filter(row.names()=='Pontiac Firebird')
mtcars %>%
mutate(model = row.names)
mtcars %>%
add_rownames(var="model") %>%
filter(model=='Pontiac Firebird')
mtcars %>%
add_rownames(var="model") %>%
filter(model=='Pontiac Firebird') %>%
select(mpg)
mtcars[25,1]
which(row.names(mtcars)=='Pontiac Firebird') - 1   ##gives us the row just before Pontiac Firebird
data<-read.csv('ebird/Ebird_DE.csv')
data %>% head
data[data$breeder==1 & data$passerine==1,grepl('^X',colnames(data))]
grepl('^X',colnames(data))],2,mean
grepl('^X',colnames(data))],2,mean)
grepl('^X',colnames(data))
result <- data %>%
filter(breeder==1,
passerine==1,
grepl('^X',colnames()))
result <- data %>%
filter(breeder==1,
passerine==1,
grepl('^X',colnames))
result <- data %>%
filter(breeder==1,
passerine==1) %>%
select(contains(X))
result <- data %>%
filter(breeder==1,
passerine==1) %>%
select(contains('X'))
head(result)
plot(result, type='l',xaxt='n',ylab='prevelance', xlab='quarter month')
head(result)
result <- data %>%
filter(breeder==1,
passerine==1) %>%
select(contains('X')) %>%
gather("quarter_month","value")
ggplot(data=result, aes(x=quarter_month, y=value)
geom_point()
ggplot(data=result, aes(x=quarter_month, y=value) + geom_point()
ggplot(data=result, aes(x=quarter_month, y=value)) + geom_point()
ggplot(data=result, aes(x=quarter_month, y=value)) + geom_point()
paste('hello','world')
#paste0 does not
paste0('hello','world')
#so we have to tell it what we want between each object
paste0('hello',' ','world')  # if you notice we told it to put a space (' ') between Hello and World
name<-'Matt'
paste0('hello, ',name,' how are you?')
foo<-function(name){paste0('hello,',name,' how are you')}
foo(name='matt')
foo('matt')
folder<-'Monstersinc'
file<-'scaretotal_MikeW_March.csv'
paste0(folder,'/',file)   # so its going to look in what ever folder we told it (Monstersinc in this case)
read.csv(paste0(folder,'/',file))
setwd('Monstersinc')
name<-'MikeW'
month<-'March'
####read in this file
data<-read.csv(paste0('scaretotal_',name,'_',month,'.csv'))
our.list<-list()
name<-c('MikeW','JamesS')
month<-c('March','April')
for(i in name){
for(p in month){
our.list[[paste0(i,'_',p)]]<-read.csv(paste0('scaretotal_',i,'_',p,'.csv'))
}  ##end p loop
}   ###end i loop
summary(our.list)
data<-c(1:10)   ###data as a vector
ci<-.01         ###confidence
sd.data<-sd(data)   #this function calculates the standard deviation, whew that was easy
sd.data
n<-length(data)    #length takes the length of a vector, well thats the same as N, right?
sem<-sd.data/n    # put them together. And there we go, we have sd/sqrt(n) also known as the standard error of the mean (sem)
tvalue<-qt(ci,(length(data)-1))   ###with that we can write this
mean.data<-mean(data)   ##the mean can be calculated with the mean function
sem*tvalue   ##gives us our interval
upper<-mean.data + sem*tvalue   ##putting it all together, this gives us our upper range
lower<-mean.data - sem*tvalue   ## our lower
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
data<-c(1:10)   ###data as a vector
ci<-.01         ###confidence
if(ci>abs(1)){print("You can't have a probability greater than 1 stupid!")}else{
sd.data<-sd(data)
n<-length(data)
sem<-sd.data/n
tvalue<-qt(ci,(length(data)-1))
mean.data<-mean(data)
upper<-mean.data + sem*tvalue
lower<-mean.data - sem*tvalue
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
list1<-list(upperbound=upper,lowerbound=lower,mean=mean.data)
}
CI.fun<-function(data,ci){
if(ci>abs(1)){print("You can't have a probability greater than 1 stupid!")}else{
sd.data<-sd(data)
n<-length(data)
sem<-sd.data/n
tvalue<-qt(ci,(length(data)-1))
mean.data<-mean(data)
upper<-mean.data + sem*tvalue
lower<-mean.data - sem*tvalue
print(paste0('your upper bound is: (',upper, ') and your lower bound is: (', lower,"), and your mean is: (", mean.data,')'))
list1<-list(upperbound=upper,lowerbound=lower,mean=mean.data)
}}
##and now we can feed it whatever data vector and confidence interval we want
result<-CI.fun(1:100,.95)    ##try it with a data vector of all integers between 1 and 100
result<-CI.fun(sample.int(100,20),.95)   ###try it with a data vector of 20 random numbers
CI.fun(1:10,2)
CI.fun<-function(data,ci){
range<-sd(data)/length(data) * qt(ci,(length(data)-1))
mean.data<-mean(data)
list1<-list(upper=mean.data+range,lower=mean.data-range,mean=mean.data)
print(list1)
}
result<-CI.fun(1:10,.95)
